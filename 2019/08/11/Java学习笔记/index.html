<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>Java学习笔记 | YQ</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="把Java学习过程中的一些知识点记下来，加深印象以及方便日后复习 主要参考资料：Thinking in Java, 4th Edition, Bruce Eckel    基本概念Java的数据类型 Java有两种数据类型：基本数据类型和引用数据类型 基本数据类型：3类8种，包括数值型（整数型：byte、short、int、long，浮点型：float、double），字符型char，布尔型boo">
<meta name="keywords" content="Java">
<meta property="og:type" content="article">
<meta property="og:title" content="Java学习笔记">
<meta property="og:url" content="http://yoursite.com/2019/08/11/Java学习笔记/index.html">
<meta property="og:site_name" content="YQ">
<meta property="og:description" content="把Java学习过程中的一些知识点记下来，加深印象以及方便日后复习 主要参考资料：Thinking in Java, 4th Edition, Bruce Eckel    基本概念Java的数据类型 Java有两种数据类型：基本数据类型和引用数据类型 基本数据类型：3类8种，包括数值型（整数型：byte、short、int、long，浮点型：float、double），字符型char，布尔型boo">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://yoursite.com/2019/08/11/Java学习笔记/Collections.png">
<meta property="og:updated_time" content="2019-08-13T15:28:43.691Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java学习笔记">
<meta name="twitter:description" content="把Java学习过程中的一些知识点记下来，加深印象以及方便日后复习 主要参考资料：Thinking in Java, 4th Edition, Bruce Eckel    基本概念Java的数据类型 Java有两种数据类型：基本数据类型和引用数据类型 基本数据类型：3类8种，包括数值型（整数型：byte、short、int、long，浮点型：float、double），字符型char，布尔型boo">
<meta name="twitter:image" content="http://yoursite.com/2019/08/11/Java学习笔记/Collections.png">
  
    <link rel="alternate" href="/atom.xml" title="YQ" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">YQ</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">My Hexo Blog</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Java学习笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/08/11/Java学习笔记/" class="article-date">
  <time datetime="2019-08-10T16:00:00.000Z" itemprop="datePublished">2019-08-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/技术/">技术</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Java学习笔记
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>把Java学习过程中的一些知识点记下来，加深印象以及方便日后复习</p>
<p>主要参考资料：Thinking in Java, 4th Edition, Bruce Eckel  </p>
<hr>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="Java的数据类型"><a href="#Java的数据类型" class="headerlink" title="Java的数据类型"></a>Java的数据类型</h3><ul>
<li>Java有两种数据类型：基本数据类型和引用数据类型</li>
<li>基本数据类型：3类8种，包括数值型（整数型：byte、short、int、long，浮点型：float、double），字符型char，布尔型boolean</li>
<li>引用数据类型：类class，接口interface，数组</li>
</ul>
<a id="more"></a>
<table>
<thead>
<tr>
<th style="text-align:center">数据类型</th>
<th style="text-align:center">占用存储空间</th>
<th style="text-align:center">表数范围</th>
<th style="text-align:center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">byte</td>
<td style="text-align:center">1字节</td>
<td style="text-align:center">-2^7 — 2^7-1</td>
<td style="text-align:center">1 byte = 8 bit</td>
</tr>
<tr>
<td style="text-align:center">short</td>
<td style="text-align:center">2字节</td>
<td style="text-align:center">-2^15 — 2^15-1</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">int</td>
<td style="text-align:center">4字节</td>
<td style="text-align:center">-2^31 — 2^31-1</td>
<td style="text-align:center">整型默认为int</td>
</tr>
<tr>
<td style="text-align:center">long</td>
<td style="text-align:center">8字节</td>
<td style="text-align:center">-2^63 — 2^63-1</td>
<td style="text-align:center">赋值long型数字后面要加L</td>
</tr>
<tr>
<td style="text-align:center">float</td>
<td style="text-align:center">4字节</td>
<td style="text-align:center">-3.403E38 — 3.403E38</td>
<td style="text-align:center">赋值float型数字后面要加F</td>
</tr>
<tr>
<td style="text-align:center">double</td>
<td style="text-align:center">8字节</td>
<td style="text-align:center">-1.798E308 — 1.798E308</td>
<td style="text-align:center">浮点型默认为double</td>
</tr>
<tr>
<td style="text-align:center">char</td>
<td style="text-align:center">2字节</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">boolean</td>
<td style="text-align:center">1 bit</td>
<td style="text-align:center"></td>
<td style="text-align:center">不能用0 1代替true false</td>
</tr>
<tr>
<td style="text-align:center">引用数据类型</td>
<td style="text-align:center">4字节</td>
<td style="text-align:center"></td>
<td style="text-align:center">代表的是对象的地址</td>
</tr>
</tbody>
</table>
<ul>
<li>浮点型不是精确的，有误差，一般不用于两数比较；如果要精确计算，需要使用java.math包下面的类BigInteger和BigDecimal</li>
<li>char类型赋值用单引号，用来表示Unicode编码表中的字符（中文也可以）（String是字符序列，用双引号）char也可表示转义符</li>
</ul>
<h3 id="主类型的默认值"><a href="#主类型的默认值" class="headerlink" title="主类型的默认值"></a>主类型的默认值</h3><table>
<thead>
<tr>
<th style="text-align:center">boolean</th>
<th style="text-align:center">char</th>
<th style="text-align:center">byte</th>
<th style="text-align:center">short</th>
<th style="text-align:center">int</th>
<th style="text-align:center">long</th>
<th style="text-align:center">float</th>
<th style="text-align:center">double</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">false</td>
<td style="text-align:center">null</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0L</td>
<td style="text-align:center">0.0f</td>
<td style="text-align:center">0.0d</td>
</tr>
</tbody>
</table>
<h3 id="不同进制数的表达"><a href="#不同进制数的表达" class="headerlink" title="不同进制数的表达"></a>不同进制数的表达</h3><ul>
<li>八进制整数：以0开头，例如015</li>
<li>十六进制整数：以0x或0X开头，例如0x15</li>
<li>二进制整数：以0b或0B开头，例如0b101</li>
</ul>
<h3 id="变量与常量"><a href="#变量与常量" class="headerlink" title="变量与常量"></a>变量与常量</h3><ul>
<li>局部变量：方法或语句块内部定义的变量，必须先初始化再使用</li>
<li>成员变量：方法外部、类内部定义的变量，会自动获得默认初始值</li>
<li>静态变量：使用static定义，从属于类</li>
<li>常量：用final修饰</li>
</ul>
<h3 id="类-class"><a href="#类-class" class="headerlink" title="类 class"></a>类 class</h3><ul>
<li>一个类实际是指“一类对象”，例如鸟类、鱼类，从属于这个类的所有对象都共享这些特征与行为，所以“类”是对属于这一类的所有对象的外观及行为进行的一种描述</li>
<li>类名+方法名：即此方法返回值返回的是指向这个类的一个对象（的句柄）</li>
</ul>
<h3 id="方法-method"><a href="#方法-method" class="headerlink" title="方法 method"></a>方法 method</h3><ul>
<li>方法的声明格式：<code>[修饰符1 修饰符2] 返回值类型 方法名(形参列表){语句}</code></li>
<li>形参：用于接收外界传入的数据；实参：调用方法时实际传递给方法的数据；返回值类型：返回的数据类型，如无则必须指定为void</li>
<li>传递实参时传递的是数据的副本</li>
<li>return语句：终止方法的运行并返回值，可以直接return结束方法</li>
</ul>
<h3 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h3><ul>
<li>首位可以是字母、下划线、美元符</li>
<li>类名：每个单词的首字母大写</li>
<li>方法名和变量名：第一个单词小写，从第二个单词开始首字母大写，即“驼峰原则”</li>
<li>常量名：全部大写，下划线连接</li>
</ul>
<hr>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><ul>
<li>二元运算符：<code>+, -, *, /, %</code></li>
<li>如果两个操作数有一个为long，则结果也为long，否则为int；如果两个操作数有一个为double，则结果也为double，否则为float；取余的余数符号与左边操作数相同</li>
<li>一元运算符：<code>++, --</code></li>
<li>自增自减；b=a++，a先赋值给b，再自增；b=++a，a先自增，再赋值给b</li>
</ul>
<h3 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h3><ul>
<li><code>+=, -=, *=, /=</code></li>
<li>说明：a+=b，即a=a+b</li>
</ul>
<h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><ul>
<li><code>=</code></li>
</ul>
<h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><ul>
<li><code>&gt;, &lt;, &gt;=, &lt;=, ==, !=, instanceof</code></li>
<li>关系运算的结果是布尔值；==和!=适用于所有数据类型；&gt;，&lt;，&gt;=，&lt;=仅适用于数值型和字符型；instanceof用于判断左边的对象是否由右边的类或子类所创建</li>
</ul>
<h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><ul>
<li><code>&amp;（与），|（或），!（非），&amp;&amp;（短路与），||（短路或），^（异或）</code></li>
<li>短路与：若第一个是false，则第二个不计算，结果直接为false；短路或：若第一个是true，则第二个不计算，结果直接为true</li>
<li>优先级：非&gt;与&gt;或</li>
</ul>
<h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><ul>
<li><code>&amp;（按位与），|（按位或），^（按位异或），~（取反），&gt;&gt;（右移），&lt;&lt;（左移）</code></li>
<li>左移1位相当于乘2，右移1位相当于除2取商</li>
</ul>
<h3 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符"></a>条件运算符</h3><ul>
<li><code>? :</code></li>
<li>此为三元运算符，例：a?b:c，即如果a是true，则结果为b，否则结果为c</li>
</ul>
<hr>
<h2 id="初始化机制"><a href="#初始化机制" class="headerlink" title="初始化机制"></a>初始化机制</h2><h3 id="构造器（构造方法）constructor"><a href="#构造器（构造方法）constructor" class="headerlink" title="构造器（构造方法）constructor"></a>构造器（构造方法）constructor</h3><ul>
<li>构造器是一种特殊的方法，方法的所有特性都适用于它，但没有返回值</li>
<li>构造器的名字与类名相同，可以有自变量</li>
<li>如果没有定义构造器，编译器会自动定义一个无参构造器（或叫默认构造器），如果已定义则不会添加</li>
<li>一个类可以有多个构造器，即方法过载</li>
</ul>
<h3 id="过载（重载）overload"><a href="#过载（重载）overload" class="headerlink" title="过载（重载）overload"></a>过载（重载）overload</h3><ul>
<li>过载的意义：为了让相同的方法名伴随不同的自变量使用</li>
<li>方法名相同，但形参个数、类型、顺序不同，即构成过载，是不同的方法，即每个过载的方法都必须采取独一无二的自变量类型列表</li>
<li>如果只有返回值不同，或者只有参数名不同，不构成过载</li>
</ul>
<h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><ul>
<li>使用范围：方法内部</li>
<li>使用方法：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><ul>
<li>在static方法中不可直接访问非static成员</li>
</ul>
<h3 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h3><ul>
<li>enum关键字使得在需要群组并使用枚举类型集时，可以很方便，使用enum时需要创建一个该类型的引用，并将其赋值给某个实例</li>
<li>enum实际上是一个类，并且它可以在switch-case语句里面使用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//Spiciness.java</span><br><span class="line">public enum Spiciness &#123;</span><br><span class="line">    NOT, MILD, MEDIUM, HOT, FLAMING</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//SimpleEnumUse.java</span><br><span class="line">class SimpleEnumUse &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Spiciness howHot = Spiciness.MEDIUM;</span><br><span class="line">        System.out.println(howHot);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="访问权限控制"><a href="#访问权限控制" class="headerlink" title="访问权限控制"></a>访问权限控制</h2><h3 id="包-package"><a href="#包-package" class="headerlink" title="包 package"></a>包 package</h3><ul>
<li>包用来管理类，解决类重名的问题</li>
<li>package的声明语句必须作为文件的第一个非注释语句出现</li>
<li>package名称一般用公司或者作者的域名倒写，再加上模块名，保证独一无二</li>
</ul>
<h3 id="访问控制符"><a href="#访问控制符" class="headerlink" title="访问控制符"></a>访问控制符</h3><ul>
<li>使用访问控制符的原因：一是规定用户哪些能用、哪些不能用，防止用户接触他们不应接触的东西；二是将接口与实施细节分离，隐藏实施细节，这样做修改调整时不会对用户产生影响</li>
<li>鉴于以上两点原因，在阅读别人的源码时，可以先着重查看public成员，因为它们可从外部访问，是对用户来说最重要的部分，而非公共成员往往是实施细节的一部分了</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">访问控制符</th>
<th style="text-align:center">同一个类</th>
<th style="text-align:center">同一个包中的类</th>
<th style="text-align:center">其他包中的子类</th>
<th style="text-align:center">所有类</th>
<th style="text-align:center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">private</td>
<td style="text-align:center">√</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">只有自己类能用</td>
</tr>
<tr>
<td style="text-align:center">default</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">没有修饰符即是default，只有同一个包中的类能访问</td>
</tr>
<tr>
<td style="text-align:center">protected</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center"></td>
<td style="text-align:center">可以被同一个包的类以及其他包中的子类访问</td>
</tr>
<tr>
<td style="text-align:center">public</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">可以被所有包中所有类访问</td>
</tr>
</tbody>
</table>
<ul>
<li>private：只有自己类能用；将一个方法设为private，可以防止在其他地方更改或删除；如果将类的默认构造器设为private，可以防止对这个类的继承</li>
<li>每个Java源文件只能有一个public类，并且类名与文件名必须相同；允许Java源文件没有任何public类</li>
<li>不可将类设为private或protected，类只能是public或default；如果不愿其他人访问这个类，可将其构造器设为private</li>
<li>没有明确包名并且位于相同目录中的不同文件，Java把它们视为那个目录“默认包”的一部分，即这一目录下的其他文件都能对其访问</li>
</ul>
<hr>
<h2 id="类再生"><a href="#类再生" class="headerlink" title="类再生"></a>类再生</h2><h3 id="合成-composition"><a href="#合成-composition" class="headerlink" title="合成 composition"></a>合成 composition</h3><ul>
<li>合成是指通过new关键字在新类中创建原有类的对象，以实现类再生和代码的重复使用</li>
</ul>
<h3 id="继承-inheritance"><a href="#继承-inheritance" class="headerlink" title="继承 inheritance"></a>继承 inheritance</h3><ul>
<li>使用extends关键字实现类的继承</li>
<li>继承的一个好处：支持累积开发，即允许引入新的代码，同时不会为现有代码造成错误，将新错误隔离在新代码里面</li>
<li>Java的类只有单继承，即只有一个父类，不像C++有多继承（但Java的接口可以多继承）</li>
<li>子类继承父类后，可以得到父类的所有属性和方法（除了父类的构造方法），但不一定可以直接访问，比如父类中private的属性和方法</li>
<li>如果定义一个类时没有用extends，那么默认父类是java.lang.Object，所有Java类都有Object类的属性和方法</li>
<li>父类要想正确初始化，需要在构造器中初始化，在子类的构造器中，Java会自动插入对父类构造器的调用；子类重写父类方法后，可以通过super关键字调用被子类覆盖的父类的原方法和属性</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class FatherClass &#123;</span><br><span class="line">    FatherClass()&#123;</span><br><span class="line">        System.out.println(&quot;FatherClass&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void test()&#123;</span><br><span class="line">        System.out.println(&quot;test1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ChildClass extends FatherClass &#123;</span><br><span class="line">    ChildClass()&#123;                                //子类构造器中，Java会自动插入对父类构造器的调用</span><br><span class="line">        System.out.println(&quot;ChildClass&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void test()&#123;                          //重写父类中的方法test()</span><br><span class="line">        System.out.println(&quot;test2&quot;);</span><br><span class="line">        super.test();                            //调用方法test()的父类版本</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ChildClass c = new ChildClass();</span><br><span class="line">        c.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果父类没有默认构造器，或者子类想调用含有自变量的某个父类构造器，必须明确编写对父类的调用代码</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Game &#123;</span><br><span class="line">    Game(int i)&#123;                                 //父类Game的构造器含有一个自变量</span><br><span class="line">        System.out.println(&quot;Game&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class BoardGame extends Game &#123;</span><br><span class="line">    BoardGame(int i)&#123;</span><br><span class="line">        super(i);                                //注意子类调用的格式</span><br><span class="line">        System.out.println(&quot;BoardGame&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Chess extends BoardGame &#123;</span><br><span class="line">    Chess()&#123;</span><br><span class="line">        super(8);                                //注意子类调用的格式</span><br><span class="line">        System.out.println(&quot;Chess&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Chess c = new Chess();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="合成与继承"><a href="#合成与继承" class="headerlink" title="合成与继承"></a>合成与继承</h3><ul>
<li>合成与继承都是实现类再生、代码重复利用的手段</li>
<li>如果想利用新类内部一个现有类的特性，而不想使用它的接口，通常用合成</li>
<li>选择继承，就需要在现有类的基础上，制作它的一个特殊版本；如果必须要上溯造型，就要用继承</li>
<li>总之，合成表达的是“包含”关系，继承表达的是“属于”关系</li>
</ul>
<h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><ul>
<li>final修饰变量，则变量只能被读取，不可再更改，不能被重新赋值，但仍能为其分配一个null空句柄</li>
<li>final修饰方法，则方法不可被子类重写，子类无法覆盖或改写，但可被过载；注意类中所有private方法都自动成为final</li>
<li>final修饰类，则类不能被继承，类中所有方法都默认为final</li>
</ul>
<h3 id="初始化-initialize"><a href="#初始化-initialize" class="headerlink" title="初始化 initialize"></a>初始化 initialize</h3><ul>
<li>首先，当前类如果有父类，Java会找到并载入父类</li>
<li>接着，在父类执行static初始化，然后在子类中执行static初始化，（注意static初始化只会在必要的时候进行，仅发生一次，之后不会再重新初始化）至此，必要的类已全部加载完毕</li>
<li>然后，执行main方法，开始创建对象，非static成员会初始化，先调用父类构造器，再调用子类构造器</li>
<li>最后，执行程序的剩余部分</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">//初始化的整个过程</span><br><span class="line">class Insect &#123;</span><br><span class="line">    int i = 9;</span><br><span class="line">    int j;</span><br><span class="line"></span><br><span class="line">    Insect()&#123;                                              //5.在初始化父类的所有数据类型后调用父类构造器</span><br><span class="line">        prt(&quot;i=&quot;+i+&quot;, j=&quot;+j);</span><br><span class="line">        j = 39;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static int x1 = prt(&quot;static Insect.x1 initialized&quot;);   //2.在父类Insect中执行static初始化</span><br><span class="line"></span><br><span class="line">    static int prt(String s)&#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        return 47;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Beetle extends Insect &#123;                       //1.Java运行Beetle时，首先会将父类Insect载入</span><br><span class="line">    int k = prt(&quot;Beetle.k initialized&quot;);</span><br><span class="line"></span><br><span class="line">    Beetle()&#123;                                              //6.在初始化子类的所有数据类型后调用子类构造器</span><br><span class="line">        prt(&quot;k=&quot;+k);</span><br><span class="line">        prt(&quot;j=&quot;+j);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static int x2 = prt(&quot;static Beetle.x2 initialized&quot;);   //3.在子类Beetle中执行static初始化</span><br><span class="line"></span><br><span class="line">    static int prt(String s)&#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        return 63;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;               //4.执行main方法，开始创建对象</span><br><span class="line">        prt(&quot;Beetle constructor&quot;);</span><br><span class="line">        Beetle b = new Beetle();</span><br><span class="line">        prt(&quot;the end&quot;);                                    //7.最后执行剩余部分</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="重写（覆盖）override"><a href="#重写（覆盖）override" class="headerlink" title="重写（覆盖）override"></a>重写（覆盖）override</h3><ul>
<li>子类继承父类后，重写父类的方法，用自身的行为替换父类的行为</li>
<li>重写的方法名和形参列表要相同；返回值类型和声明异常类型，子类要小于等于父类；访问权限，子类要大于等于父类</li>
<li>注意重写与过载的区别</li>
</ul>
<hr>
<h2 id="多形性（多态）polymorphism"><a href="#多形性（多态）polymorphism" class="headerlink" title="多形性（多态）polymorphism"></a>多形性（多态）polymorphism</h2><ul>
<li>调用同一个方法，由于对象不同可能会有不同的行为</li>
<li>多态是方法的多态，不是属性的多态</li>
<li>多态存在的3个必要条件：继承；方法重写；父类引用指向子类对象</li>
<li>多态这部分需要补充例证：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><h3 id="抽象-abstract"><a href="#抽象-abstract" class="headerlink" title="抽象 abstract"></a>抽象 abstract</h3><ul>
<li>抽象方法：使用abstract修饰的方法，没有方法体，没有花括号，只有一个声明，便于子类方法提供具体实现</li>
<li>抽象类：含有抽象方法的类，必须指定为abstract，抽象类仅仅表达接口，不含具体实施细节</li>
<li>抽象类不能合成（不能用new关键字创建对象），只能被子类调用、继承，便于严格控制子类的设计，使子类之间更加通用</li>
</ul>
<h3 id="接口-interface"><a href="#接口-interface" class="headerlink" title="接口 interface"></a>接口 interface</h3><ul>
<li>接口可以理解为一个“纯”抽象类，用于建立类与类之间的一个“协议”</li>
<li>接口和抽象的选择？使用接口，可以同时获得抽象类和接口，因此多数情况使用接口</li>
<li>接口的访问控制符只能是public或default</li>
<li>接口中的属性只能是常量，总是public static final修饰，不写也是</li>
<li>接口中的方法只能是public abstract，不写也是</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">interface Interface01 &#123; int MAX_VALUE = 100; &#125;           //属性只能是常量，总是public static final修饰，不写也是</span><br><span class="line"></span><br><span class="line">interface Interface02 &#123; void fly(); &#125;                    //方法只能是public abstract，不写也是</span><br><span class="line"></span><br><span class="line">interface Interface03 extends Interface01,Interface02 &#123;&#125; //接口与接口之间使用extends可以实现多继承</span><br><span class="line"></span><br><span class="line">class Class01 implements Interface01,Interface02 &#123;       //使用implements生成与接口相符的类，可以跟多个接口</span><br><span class="line"></span><br><span class="line">    @Override                                            //必须重写接口中的所有方法，否则只能将类设为抽象类</span><br><span class="line">    public void fly() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><ul>
<li>将一个类的定义放在另一个类的定义内部</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="对象的容纳"><a href="#对象的容纳" class="headerlink" title="对象的容纳"></a>对象的容纳</h2><h3 id="数组-array"><a href="#数组-array" class="headerlink" title="数组 array"></a>数组 array</h3><ul>
<li>数组代表一系列对象或基本数据类型，是相同数据类型的有序集合，每一个数据称为一个元素，每个元素可以通过索引下标来访问</li>
<li>特点：长度是确定的，一旦被创建，大小不可更改；元素必须是相同类型，不能是混合类型；数组类型可以是任何数据类型，包括基本类型和引用类型</li>
<li>对象数组和基本数据类型数组在使用方法上几乎完全一样，唯一的差别在于对象数组容纳的是句柄，而基本数据类型数组容纳的是具体数值</li>
<li>数组可以用作方法的返回值类型，即“返回一个数组”，此时返回的是指向数组的句柄</li>
<li>数组的初始化，见下面示例代码</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">class User &#123; String name; &#125;</span><br><span class="line"></span><br><span class="line">class Arrays &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] a1 = &#123;1,2,3&#125;;                        //静态初始化</span><br><span class="line">        int[] a2;</span><br><span class="line">        a2 = a1;                                   //不是赋值，是传递句柄，a1和a2指向内存堆里同样的数组对象</span><br><span class="line"></span><br><span class="line">        for (int i=0; i&lt;a2.length; i++) &#123;</span><br><span class="line">            a2[i]++;</span><br><span class="line">            System.out.println(&quot;a2[&quot;+i+&quot;]=&quot;+a2[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        for (int i=0; i&lt;a1.length; i++) &#123;</span><br><span class="line">            System.out.println(&quot;a1[&quot;+i+&quot;]=&quot;+a1[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        User[] a3;                                 //数组元素可以是任何数据类型</span><br><span class="line">        Integer[] a4;                              //注意Integer是一个类</span><br><span class="line">        int[] a5 = new int[5];                     //连长度一起定义</span><br><span class="line">        a5[0] = 2;                                 //通过索引下标给元素赋值</span><br><span class="line"></span><br><span class="line">        for (int i=0; i&lt;a5.length; i++)&#123;           //通过循环给数组元素赋值（如果元素值有规律的话）</span><br><span class="line">            a5[i] = 10*i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i=0; i&lt;a5.length; i++)&#123;           //通过循环读取元素值</span><br><span class="line">            System.out.println(a5[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i:a5) &#123;                           //foreach用于读取数组或集合中的所有元素，不能做修改</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MultiDimensionArrays &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        //静态初始化一个二维数组</span><br><span class="line">        int[][] a1 = &#123;                         </span><br><span class="line">                &#123;1, 2, 3, &#125;,</span><br><span class="line">                &#123;4, 5, 6, &#125;,</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        //固定大小的三维数组，可通过for嵌套循环对元素进行操作</span><br><span class="line">        int[][][] a2 = new int[2][3][4];       </span><br><span class="line">        for (int i=0; i&lt;a2.length; i++)&#123;</span><br><span class="line">            for (int j=0; j&lt;a2[i].length; j++)&#123;</span><br><span class="line">                for (int k=0; k&lt;a2[i][j].length; k++)&#123;</span><br><span class="line">                    System.out.println(&quot;a2[&quot;+i+&quot;][&quot;+j+&quot;][&quot;+k+&quot;]=&quot;+a2[i][j][k]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //一开始没有完全固定大小的三维数组，通过3个new逐级固定三维的大小</span><br><span class="line">        int[][][] a3 = new int[2][][];         </span><br><span class="line">        for (int i=0; i&lt;a3.length; i++)&#123;</span><br><span class="line">            a3[i] = new int[3][];</span><br><span class="line">            for (int j=0; j&lt;a3[i].length; j++)&#123;</span><br><span class="line">                a3[i][j] = new int[4];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="泛型-generics"><a href="#泛型-generics" class="headerlink" title="泛型 generics"></a>泛型 generics</h3><ul>
<li>通过使用泛型，预先指定容器所能保存的类型（此类的子类型也允许），可以在编译期防止将错误类型的对象放置在容器中，简单实例如下</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Apple &#123;</span><br><span class="line">    private static long counter;</span><br><span class="line">    private final long id = counter++;</span><br><span class="line">    public long id()&#123; return id; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Orange &#123;&#125;</span><br><span class="line"></span><br><span class="line">class ApplesAndOrangesWithGenerics &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //此处使用了泛型，&lt;&gt;内是类型参数，可以有多个，指定了这个容器实例所能保存的类型</span><br><span class="line">        ArrayList&lt;Apple&gt; apples = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        for (int i=0; i&lt;3; i++)&#123;</span><br><span class="line">            apples.add(new Apple());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //有了泛型，下一句将类Orange添加到apples里面的操作在编译期就能示错；没有泛型，只有程序运行之后才能示错</span><br><span class="line">        //apples.add(new Orange());</span><br><span class="line"></span><br><span class="line">        for (int i=0; i&lt;apples.size(); i++)&#123;</span><br><span class="line">            System.out.println(apples.get(i).id());</span><br><span class="line">        &#125;</span><br><span class="line">        for (Apple c:apples) &#123;</span><br><span class="line">            System.out.println(c.id());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="容器（集合）Collection"><a href="#容器（集合）Collection" class="headerlink" title="容器（集合）Collection"></a>容器（集合）Collection</h3><ul>
<li>为容纳一组对象，首选通常是数组，但如果不知道需要多少个对象，或者保存方式比较复杂，可能会采用容器，因为容器可以自动调整大小</li>
<li>容器只能容纳对象句柄，不能容纳基本数据类型</li>
<li>容器包括两大类：Collection（元素独立）和 Map（含有成对的键值对，类似于字典），其中 Collection 包括List（必须按照插入的顺序保存元素）、Set（不能有重复元素）、Queue（一端插入对象，另一端移除对象）</li>
</ul>
<img src="/2019/08/11/Java学习笔记/Collections.png" title="This is an example image">
<ul>
<li>关于 <code>List&lt;Apple&gt; apples = new ArrayList&lt;&gt;();</code> 与 <code>ArrayList&lt;Apple&gt; apples = new ArrayList&lt;&gt;();</code> 的区别：前者apples用到的是List接口中的方法，无法调用List接口以外的方法；后者apples调用的是ArrayList类中的方法，ArrayList类是List接口的实现，有一些有别于List接口的方法；当代码写完发现需要将容器类型更改为LinkedList，对于前者，只需替换创建语句为 <code>List&lt;Apple&gt; apples = new LinkedList&lt;&gt;();</code> 即可，后面的代码不需要修改，因为apples用的是List接口中的方法，同样适用于LinkedList，而对于后者，就不能直接这样替换，因为apples调用的是ArrayList类中的方法，不一定适用于LinkedList</li>
</ul>
<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><ul>
<li>使用方法add()插入对象，用get()访问对象，用size()统计元素个数</li>
<li>List接口在Collection的基础上添加了大量的方法，使得可以在List中间插入和移除元素</li>
<li>ArrayList：长于随机访问元素，但在List中间插入和移除元素时较慢</li>
<li>LinkedList：随机访问较慢，长于在List中间插入和移除元素；可以直接将其作为栈使用</li>
</ul>
<h3 id="迭代器-iterator"><a href="#迭代器-iterator" class="headerlink" title="迭代器 iterator"></a>迭代器 iterator</h3><ul>
<li>作用：遍历并选择序列中的对象，有了迭代器就不用再关注容器中的元素数量，由迭代器去关注</li>
<li>Iterator：只能单向移动，使用方法iterator()准备返回序列的第一个元素，next()获得序列中的下一个元素，hasNext()检查序列中是否还有元素，remove()将next()新近返回的元素删除</li>
<li>ListIterator：是迭代器的子类型，只能用于List类，可以双向移动，不光有hasNext()，还有hasPrevious()，还可用方法set()替换访问过的最后一个元素</li>
</ul>
<h3 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h3><ul>
<li>栈，是指“后进先出”的容器，最后压入的元素，最先弹出来，push()压入，pop()弹出</li>
</ul>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><ul>
<li>Set接口与Collection完全一样，没有任何额外的功能，只是行为不同</li>
<li>Set不保存重复的元素，最被常用的是测试归属性，查询某个对象是否在Set中，比如方法contains()</li>
<li>HashSet提供最快的查询速度；TreeSet保持元素始终处于排序状态，所以没有HashSet快；LinkedHashSet保持元素插入的顺序</li>
</ul>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><ul>
<li>保存成对的键值对，将对象映射到其他对象，类似于字典</li>
<li>HashMap用来快速访问；TreeMap保持“键”始终处于排序状态，所以没有HashMap快；LinkedHashMap保持元素插入的顺序</li>
</ul>
<h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><ul>
<li>先进先出，从一端插入元素，从另一端取出，插入与取出的顺序相同</li>
</ul>
<hr>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><h3 id="异常处理程序"><a href="#异常处理程序" class="headerlink" title="异常处理程序"></a>异常处理程序</h3><ul>
<li>try-catch-finally：将可能会引起异常的代码集中放在try块中，用try块来捕获所有异常，缺点是try中一旦有一个异常，剩下的就不执行了，所以只能将全部异常隔离在此，不能一次性找出所有异常；抛出异常后执行相应的catch语句；finally语句总能得到执行，最多只能有一条，注意，如果在finally中使用return，那么程序即使抛出了异常，也不会有任何输出</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    //可能会引起异常的代码集中在此</span><br><span class="line">&#125; catch(Type1 id1) &#123;</span><br><span class="line">    //Type1的异常处理程序</span><br><span class="line">&#125; catch(Type2 id2) &#123;</span><br><span class="line">    //Type2的异常处理程序</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    //总能得到执行的语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><ul>
<li>自定义异常需要从已有的异常类继承（Exception或RuntimeException，若是Exception则需要用try-catch捕获异常或者throws异常说明，否则编译器会报错），最简单的方法是使用默认构造器，当然也可以定义一个接受字符串参数的构造器</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">class SimpleException extends Exception &#123;&#125;</span><br><span class="line"></span><br><span class="line">class MyException extends Exception &#123;</span><br><span class="line">    public MyException()&#123;&#125;</span><br><span class="line">    public MyException(String s)&#123;super(s);&#125;         //super调用其默认构造器，接受一个字符串作为参数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class TestException &#123;</span><br><span class="line"></span><br><span class="line">    //方法后面throws加一个异常类型列表（逗号隔开），表示异常说明，告知某个方法可能会抛出异常</span><br><span class="line">    public static void f1() throws SimpleException &#123;  </span><br><span class="line">        throw new SimpleException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void f2() throws MyException &#123;</span><br><span class="line">        throw new MyException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void f3() throws MyException &#123;</span><br><span class="line">        throw new MyException(&quot;at f3()&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            f1();</span><br><span class="line">        &#125; catch (SimpleException e)&#123;</span><br><span class="line">            System.out.println(&quot;出错啦！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            f2();</span><br><span class="line">        &#125; catch (MyException e)&#123;</span><br><span class="line">            e.printStackTrace(System.out);   //printStackTrace()打印从方法调用处到异常抛出处的方法调用序列</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            f3();</span><br><span class="line">        &#125; catch (MyException e)&#123;</span><br><span class="line">            e.printStackTrace(System.out);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="捕获所有异常"><a href="#捕获所有异常" class="headerlink" title="捕获所有异常"></a>捕获所有异常</h3><ul>
<li>通过捕获异常类型的基类Exception，就可以实现一个异常处理程序捕获所有异常，注意这个作用是不遗漏任何一个异常，而不是一次性捕获所有异常（因为受限于try的顺序执行），所以可以把下面这一句catch放在异常处理程序的末尾，以达到“最后一道防线”的效果</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">catch (Exception e) &#123; e.printStackTrace(System.out); &#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/08/11/Java学习笔记/" data-id="cjz9zm1pl000dk0v0cpkoi5aw" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2019/08/05/Maven基本概念和操作/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Maven基本概念和操作</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/技术/">技术</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hexo/">Hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Maven/">Maven</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/Maven/" style="font-size: 10px;">Maven</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/08/11/Java学习笔记/">Java学习笔记</a>
          </li>
        
          <li>
            <a href="/2019/08/05/Maven基本概念和操作/">Maven基本概念和操作</a>
          </li>
        
          <li>
            <a href="/2019/08/01/基于hexo搭建个人博客并利用Github部署到远端/">基于hexo搭建个人博客并利用Github部署到远端</a>
          </li>
        
          <li>
            <a href="/2019/07/31/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>